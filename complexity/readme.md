# 算法复杂度

## 原因

为了知道自己写的代码运行究竟需要多少时间和空间,我们需要对算法的复杂度进行分析.

同样的一段代码,如果在不同的机器上进行测试,其CPU,内存频率,操作系统的不同都会导致不同的运行时间出现,这些被统称为**事后统计法**.

事后统计法有其自身的缺陷,但是其方法并没有问题,在更多的时候我们采用**事先统计法**.

## 时间复杂度

渐进时间复杂度（asymptotic time complexity），简称时间复杂度,一般使用大O进行代替.

### O(n)

有一个函数如下:

```c
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

假设一个操作需要运行的时间为$u$,则上面的函数所需要的总时间为$$u+u+u*n+u = (n+3)*u$$,可以看出来 总时间与u成正比,而在比值中,n的取值决定了其总运行时间,使用大O统计法,表示为O(n),忽略其常数项.

### O($$n^2$$)

有代码如下,其中包含了两个次数为n的循环,因此,我们可以认为其时间复杂度为O($$n^2$$)

```c

 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```

### 加法法则

总复杂度等于量级最大的那段代码的复杂度

在下面代码中,每个循环的时间复杂度分别为O(100),O($n$),O($$n^2$$), 所以这段代码的总时间复杂度为O($$n^2$$).

```c

int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
```

### 乘法法则

嵌套代码的复杂度等于嵌套内外代码复杂度的乘积.

代码如下,cal()这个函数中包含了f(),其中f()的时间复杂度为O(n), 而f()在cal中执行了n次,所以最终代码时间复杂度为O($$n*n$$)=O($$n^2$$).

```c

int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```

### O(1)

在下面的代码中,虽然实际为O(3),但我们仍称其为O(1).

```c
 int i = 8;
 int j = 6;
 int sum = i + j;
```

在一般情况下,只要算法中不存在递归,迭代(循环)语句,即使有成千上万行代码,我们仍然称其为O(1)

### O(logn)

```c
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

在上面的循环中,我们可发现其执行次数为$$log_2n$$,下面的代码循环次数为$$log_3n$$

```c
 i=1;
 while (i <= n)  {
   i = i * 3;
 }
```

我们统称其时间复杂度为O(logn).

常见的归并排序,快速排序的算法时间度是O(nlogn)

### O(m+n),O(m\*n)

在下面的代码中,第一个for循环共执行了m次,第二个执行了n次,因为$$m\neq n$$,所以我们称其时间复杂度为O(m+n)

```c

int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

如果将第二个for循环嵌入到第一个循环之后,整段代码的时间复杂度为O(m\*n)

### 总结

时间复杂度用来粗略的衡量代码段的执行效率.

![img](complexity.assets/497a3f120b7debee07dc0d03984faf04.jpg)

常见的时间复杂度有图中这些类型,另外也包含了O(n!)和O($$2^n$$)这样的NP(Nondeterministic Polynomial)非多项式问题.

上图中可以看到其顺序为:
$$
O(log n)<O(n)<O(nlogn)<O(n^2)
$$

## 空间复杂度

空间复杂度全称`渐进空间复杂度(asymptotic space complexity)`,表示算法的存储空间与数据规模之间的增长关系.

```c

void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

上面的代码中,主要生成了一个int型的变量i和一个长度为n的数组a,所以其整个代码的空间复杂度是O(1+n),一般表示为O(n).

我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。

## 复杂度分析

复杂度主要包含最好情况时间复杂度,**最坏情况时间复杂度**,**平均情况时间复杂度**,**均摊时间复杂度**四个方面.

### 最好,最坏时间复杂度

有如下代码

```c
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
```

该代码主要实现一个功能:从一个数组array中找到最后一个出现值x的位置, 根据前面所讲到的方法,这段代码的时间复杂度为O(n).

但当我们对代码做如下修改:

```c

// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

当碰到第一个与x相同的值之后,直接break循环并return. 此时代码的时间复杂度就需要进行分类判断,当array[0]==x时,整个for循环只用循环1次,**时间复杂度为O(1)**.但是只有array[-1]==x或者array中并不存在x这个值时,整个循环需要重复n次,**时间复杂度为O(n)**.

因此 针对不同情况下的时间复杂度,我们需要引入三个概念:

最好,最坏和平均情况时间复杂度.

顾名思义，最好情况时间复杂度就是，**在最理想的情况下，执行这段代码的时间复杂度。**就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。同理，最坏情况时间复杂度就是，**在最糟糕的情况下，执行这段代码的时间复杂度。**就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。

### 平均情况时间复杂度

最好情况时间复杂度和最坏情况时间复杂度对应的都是**极端情况**下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度，简称为**平均时间复杂度**。

上面的代码共有n+1种情况,每种情况需要循环的次数分别为$$1,2,3,\dots,n,n$$,对其进行平均得到$$n(n+3)/2/(n+1)$$

![img](complexity.assets/d889a358b8eccc5bbb90fc16e327a22f.jpg)

将公式化简后得到平均复杂度为O(n).

实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。像我们上一章举的那些例子那样，很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。

### ~~均摊时间复杂度~~

均摊时间复杂度名字听起来与平均时间复杂度非常像,平均时间复杂度在某些特殊情况下才会用到,而均摊时间复杂度应用场景更加特殊,有限.
